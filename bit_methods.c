#include "my_vm.h"

void print_binary(unsigned long binary_number){
    /* Given a binary number
    *  prints it for debugging purposes
    * 
    * Parameters: 
    * unsigned long: binary_number, number to print
    */
    if (binary_number) {
        //print all digits after the current one
        print_binary(binary_number >> 1);
        //print the current digit by performing modulus
        printf("%d", binary_number%2);
    }
}

void print_full_32(unsigned long binary_number, int digit_start){
    /* Given a binary number
    *  prints it for debugging purposes, prints 32 digits 
    *  (to represent a address in a 32 bit machine)
    * 
    * Parameters: 
    * unsigned long: binary_number, number to print
    */

    //print 32 items
    if(digit_start<32){
        print_full_32(binary_number >> 1, digit_start + 1);
        printf("%d", binary_number%2);
    }
    
}

bool get_bit(char * bitmap, unsigned int bit_index){
    /*
    * Gets a bit given the specific bitmap and bit index
    * 
    * Parameters:
    * void * bitmap: The bitmap to get a bit from
    * unsigned int bit_index: The specific bit index to get from
    * 
    * Returns: 
    * bool: if the bit is true or false 
    */


    //first get the index of the byte that contains the bit I want to get
    unsigned int byte_index = bit_index/8;

    //now find the bit within that byte
    unsigned int inner_bit_index = bit_index % 8;

    //get the bit mask for said bit for a comparison
    unsigned int bit_mask = (1 << inner_bit_index);

    //perform a bitwise AND between the mask we generated 
    //based off of our bit as well as well as the actual bit there
    //if the result is not 0 we know the bit was 1, otherwise the
    //bit was 0
    return (((bitmap)[byte_index] & bit_mask) != 0);
}

void set_bit(char ** bitmap, unsigned int bit_index, bool to_set){
    /*
    * Sets a bit given the specific bitmap and bit index
    * 
    * Parameters:
    * void * bitmap: The bitmap to get a bit from
    * unsigned int bit_index: The specific bit index to set
    * bool to_set: What to set the bit to (true or false)
    */


    //once again get the index of the byte that contains the bit I want to get
    unsigned int byte_index = bit_index/8;

    //and get the bit within that byte
    unsigned int inner_bit_index = bit_index % 8;

    //once again, set the bit mask for comparison
    unsigned int bit_mask;
    if(to_set){
        //if we want to set the bit to 1, bitshift 1 over
        bit_mask = (1 << inner_bit_index);
        
        //perform a bitwise OR to put the value in keeping the old values
        char new_byte = (*bitmap)[byte_index] | bit_mask;
    
        //finally set the value we want to set
        (*bitmap)[byte_index] = new_byte;
    }else{
        //otherwise we want to set the bit to 0

        //bit shift 1 over and perform a not to set it to 0 and everything else
        //to 1
        bit_mask = ~(1 << inner_bit_index);

        //perform a bitwise AND to put the value in keeping the old values
        char new_byte = (*bitmap)[byte_index] & bit_mask;
    
        //finally set the value we want to set
        (*bitmap)[byte_index] = new_byte;
    }



}

unsigned long get_bits_between(void * va, unsigned long start, unsigned long end){
    /*
    * Gets the bits between a specific set of a numbers
    * 
    * Returns: 
    * unsigned long: A number that represents the bits between the specified values
    */
    unsigned long mask = 0;
    unsigned long i;
    //generate a mask including the bits from the start to the end
    for(i = 0; i < (end-start); i++){
        //add the new bit (generated by moving 1 over as many times
        //as the current location along with a bitwise OR to add it in)
        mask = ((1<<i) | mask);
    }

    //remove all bits before the start of what we want to extract,
    //the mask will make everything after 0s
    unsigned long va_manipulated = ((unsigned long) va >> (start));
    return mask & va_manipulated;
}

